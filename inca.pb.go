// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com/aperturerobotics/inca/inca.proto

/*
Package inca is a generated protocol buffer package.

It is generated from these files:
	github.com/aperturerobotics/inca/inca.proto

It has these top-level messages:
	StorageRef
	StorageRefIPFS
	Validator
	BlockHeader
	Genesis
*/
package inca

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import crypto_pb "github.com/libp2p/go-libp2p-crypto/pb"
import timestamp "github.com/aperturerobotics/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// StorageType contains the possible types of storage.
type StorageType int32

const (
	// StorageType_UNKNOWN holds unknown values.
	StorageType_StorageType_UNKNOWN StorageType = 0
	// StorageType_IPFS is the IPFS storage type.
	StorageType_StorageType_IPFS StorageType = 1
)

var StorageType_name = map[int32]string{
	0: "StorageType_UNKNOWN",
	1: "StorageType_IPFS",
}
var StorageType_value = map[string]int32{
	"StorageType_UNKNOWN": 0,
	"StorageType_IPFS":    1,
}

func (x StorageType) String() string {
	return proto.EnumName(StorageType_name, int32(x))
}
func (StorageType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// OperationMode is the operation mode of the validator.
type Validator_OperationMode int32

const (
	// OperationMode_STAGING indicates the validator is not currently online.
	Validator_OperationMode_STAGING Validator_OperationMode = 0
	// OperationMode_OPERATING indicates the validator is currently operating.
	Validator_OperationMode_OPERATING Validator_OperationMode = 1
)

var Validator_OperationMode_name = map[int32]string{
	0: "OperationMode_STAGING",
	1: "OperationMode_OPERATING",
}
var Validator_OperationMode_value = map[string]int32{
	"OperationMode_STAGING":   0,
	"OperationMode_OPERATING": 1,
}

func (x Validator_OperationMode) String() string {
	return proto.EnumName(Validator_OperationMode_name, int32(x))
}
func (Validator_OperationMode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

// StorageRef references storage.
type StorageRef struct {
	// StorageType contains the type of storage this is.
	StorageType StorageType `protobuf:"varint,1,opt,name=storage_type,json=storageType,enum=inca.StorageType" json:"storage_type,omitempty"`
	// Ipfs contains a IPFS storage reference.
	Ipfs *StorageRefIPFS `protobuf:"bytes,2,opt,name=ipfs" json:"ipfs,omitempty"`
}

func (m *StorageRef) Reset()                    { *m = StorageRef{} }
func (m *StorageRef) String() string            { return proto.CompactTextString(m) }
func (*StorageRef) ProtoMessage()               {}
func (*StorageRef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *StorageRef) GetStorageType() StorageType {
	if m != nil {
		return m.StorageType
	}
	return StorageType_StorageType_UNKNOWN
}

func (m *StorageRef) GetIpfs() *StorageRefIPFS {
	if m != nil {
		return m.Ipfs
	}
	return nil
}

// StorageRefIPFS references an object in IPFS.
type StorageRefIPFS struct {
	// ObjectHash contains the referenced object hash.
	ObjectHash []byte `protobuf:"bytes,1,opt,name=object_hash,json=objectHash,proto3" json:"object_hash,omitempty"`
}

func (m *StorageRefIPFS) Reset()                    { *m = StorageRefIPFS{} }
func (m *StorageRefIPFS) String() string            { return proto.CompactTextString(m) }
func (*StorageRefIPFS) ProtoMessage()               {}
func (*StorageRefIPFS) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *StorageRefIPFS) GetObjectHash() []byte {
	if m != nil {
		return m.ObjectHash
	}
	return nil
}

// Validator holds information about a validator.
type Validator struct {
	// PubKey is the validator's public key.
	PubKey *crypto_pb.PublicKey `protobuf:"bytes,1,opt,name=pub_key,json=pubKey" json:"pub_key,omitempty"`
	// VotingPower is the voting power of the validator.
	VotingPower uint64 `protobuf:"varint,2,opt,name=voting_power,json=votingPower" json:"voting_power,omitempty"`
	// OperationMode is the operation mode of the validator.
	OperationMode Validator_OperationMode `protobuf:"varint,3,opt,name=operation_mode,json=operationMode,enum=inca.Validator_OperationMode" json:"operation_mode,omitempty"`
}

func (m *Validator) Reset()                    { *m = Validator{} }
func (m *Validator) String() string            { return proto.CompactTextString(m) }
func (*Validator) ProtoMessage()               {}
func (*Validator) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Validator) GetPubKey() *crypto_pb.PublicKey {
	if m != nil {
		return m.PubKey
	}
	return nil
}

func (m *Validator) GetVotingPower() uint64 {
	if m != nil {
		return m.VotingPower
	}
	return 0
}

func (m *Validator) GetOperationMode() Validator_OperationMode {
	if m != nil {
		return m.OperationMode
	}
	return Validator_OperationMode_STAGING
}

// BlockHeader is the header of a block.
type BlockHeader struct {
	// GenesisRef contains a reference to the Genesis object.
	GenesisRef *StorageRef `protobuf:"bytes,1,opt,name=genesis_ref,json=genesisRef" json:"genesis_ref,omitempty"`
}

func (m *BlockHeader) Reset()                    { *m = BlockHeader{} }
func (m *BlockHeader) String() string            { return proto.CompactTextString(m) }
func (*BlockHeader) ProtoMessage()               {}
func (*BlockHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *BlockHeader) GetGenesisRef() *StorageRef {
	if m != nil {
		return m.GenesisRef
	}
	return nil
}

// Genesis is the object containing the blockchain identity.
type Genesis struct {
	// ChainId is used to differentiate between chains, but could be set to anything.
	// It is an opaque value and ignored by the system.
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId" json:"chain_id,omitempty"`
	// Timestamp contains the time the genesis block was formed.
	Timestamp *timestamp.Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *Genesis) Reset()                    { *m = Genesis{} }
func (m *Genesis) String() string            { return proto.CompactTextString(m) }
func (*Genesis) ProtoMessage()               {}
func (*Genesis) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Genesis) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *Genesis) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func init() {
	proto.RegisterType((*StorageRef)(nil), "inca.StorageRef")
	proto.RegisterType((*StorageRefIPFS)(nil), "inca.StorageRefIPFS")
	proto.RegisterType((*Validator)(nil), "inca.Validator")
	proto.RegisterType((*BlockHeader)(nil), "inca.BlockHeader")
	proto.RegisterType((*Genesis)(nil), "inca.Genesis")
	proto.RegisterEnum("inca.StorageType", StorageType_name, StorageType_value)
	proto.RegisterEnum("inca.Validator_OperationMode", Validator_OperationMode_name, Validator_OperationMode_value)
}

func init() { proto.RegisterFile("github.com/aperturerobotics/inca/inca.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 465 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x52, 0x5f, 0x6f, 0xd3, 0x3e,
	0x14, 0x5d, 0x7e, 0xbf, 0x6a, 0xa5, 0x37, 0x5d, 0x55, 0xcc, 0xd0, 0xba, 0x21, 0xc4, 0xc8, 0x53,
	0x05, 0x6a, 0xab, 0x15, 0x78, 0xe3, 0x81, 0x21, 0xa0, 0xab, 0x2a, 0xda, 0xca, 0x2d, 0x7f, 0xde,
	0x22, 0x3b, 0xb9, 0x6d, 0xcd, 0xd2, 0xd8, 0x72, 0x1c, 0x50, 0xbe, 0x33, 0x1f, 0x02, 0xc5, 0xe9,
	0x9f, 0x84, 0x07, 0x5e, 0xac, 0x73, 0xce, 0x3d, 0x57, 0xd7, 0xd7, 0x3e, 0xf0, 0x72, 0x2d, 0xcc,
	0x26, 0xe5, 0xfd, 0x40, 0x6e, 0x07, 0x4c, 0xa1, 0x36, 0xa9, 0x46, 0x2d, 0xb9, 0x34, 0x22, 0x48,
	0x06, 0x22, 0x0e, 0x98, 0x3d, 0xfa, 0x4a, 0x4b, 0x23, 0x49, 0x2d, 0xc7, 0x57, 0xc3, 0x52, 0x4b,
	0x24, 0xb8, 0x1a, 0xaa, 0xc1, 0x5a, 0xf6, 0x0a, 0xd4, 0x0b, 0x74, 0xa6, 0x8c, 0x1c, 0x28, 0x3e,
	0x28, 0x50, 0xd1, 0x79, 0xf5, 0xe6, 0x5f, 0x63, 0x8c, 0xd8, 0x62, 0x62, 0xd8, 0x56, 0x1d, 0x51,
	0xd1, 0xe6, 0x45, 0x00, 0x0b, 0x23, 0x35, 0x5b, 0x23, 0xc5, 0x15, 0x79, 0x0d, 0xcd, 0xa4, 0x60,
	0xbe, 0xc9, 0x14, 0x76, 0x9c, 0x6b, 0xa7, 0xdb, 0x1a, 0x3e, 0xec, 0xdb, 0x1b, 0xee, 0x7c, 0xcb,
	0x4c, 0x21, 0x75, 0x93, 0x23, 0x21, 0x5d, 0xa8, 0x09, 0xb5, 0x4a, 0x3a, 0xff, 0x5d, 0x3b, 0x5d,
	0x77, 0x78, 0x5e, 0x71, 0x53, 0x5c, 0x8d, 0xe7, 0x9f, 0x16, 0xd4, 0x3a, 0xbc, 0x1b, 0x68, 0x55,
	0x75, 0xf2, 0x0c, 0x5c, 0xc9, 0x7f, 0x60, 0x60, 0xfc, 0x0d, 0x4b, 0x36, 0x76, 0x60, 0x93, 0x42,
	0x21, 0xdd, 0xb1, 0x64, 0xe3, 0xfd, 0x76, 0xa0, 0xf1, 0x95, 0x45, 0x22, 0x64, 0x46, 0x6a, 0xd2,
	0x83, 0xba, 0x4a, 0xb9, 0x7f, 0x8f, 0x99, 0xb5, 0xe6, 0xd3, 0xf6, 0xaf, 0xc0, 0xfb, 0xf3, 0x94,
	0x47, 0x22, 0x98, 0x60, 0x46, 0x4f, 0x55, 0xca, 0x27, 0x98, 0x91, 0xe7, 0xd0, 0xfc, 0x29, 0x8d,
	0x88, 0xd7, 0xbe, 0x92, 0xbf, 0x50, 0xdb, 0x1b, 0xd6, 0xa8, 0x5b, 0x68, 0xf3, 0x5c, 0x22, 0x1f,
	0xa0, 0x25, 0x15, 0x6a, 0x66, 0x84, 0x8c, 0xfd, 0xad, 0x0c, 0xb1, 0xf3, 0xbf, 0x5d, 0xfa, 0x69,
	0xb1, 0xc6, 0x61, 0x74, 0x7f, 0xb6, 0x77, 0x7d, 0x96, 0x21, 0xd2, 0x33, 0x59, 0xa6, 0xde, 0x08,
	0xce, 0x2a, 0x75, 0x72, 0x09, 0x8f, 0x2b, 0x82, 0xbf, 0x58, 0xde, 0x8e, 0xc6, 0xd3, 0x51, 0xfb,
	0x84, 0x3c, 0x81, 0x8b, 0x6a, 0x69, 0x36, 0xff, 0x48, 0x6f, 0x97, 0x79, 0xd1, 0xf1, 0xde, 0x81,
	0xfb, 0x3e, 0x92, 0xc1, 0xfd, 0x1d, 0xb2, 0x10, 0x35, 0xb9, 0x01, 0x77, 0x8d, 0x31, 0x26, 0x22,
	0xf1, 0x35, 0xae, 0x76, 0x3b, 0xb7, 0xff, 0x7e, 0x61, 0x0a, 0x3b, 0x13, 0xc5, 0x95, 0xf7, 0x1d,
	0xea, 0xa3, 0x82, 0x91, 0x4b, 0x78, 0x10, 0x6c, 0x98, 0x88, 0x7d, 0x11, 0xda, 0xd6, 0x06, 0xad,
	0x5b, 0x3e, 0x0e, 0xc9, 0x10, 0x1a, 0x87, 0x28, 0x1c, 0x3e, 0xee, 0x18, 0x8e, 0xe5, 0x1e, 0xd1,
	0xa3, 0xed, 0xc5, 0x5b, 0x70, 0x4b, 0x19, 0x20, 0x17, 0xf0, 0xa8, 0x44, 0xfd, 0x2f, 0xd3, 0xc9,
	0x74, 0xf6, 0x6d, 0xda, 0x3e, 0x21, 0xe7, 0xd0, 0x2e, 0x17, 0xf2, 0x7f, 0x6e, 0x3b, 0xfc, 0xd4,
	0x06, 0xee, 0xd5, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xdd, 0x7d, 0x3e, 0xc1, 0x10, 0x03, 0x00,
	0x00,
}
