syntax = "proto3";
package inca;

import "github.com/aperturerobotics/timestamp/timestamp.proto";
import "github.com/aperturerobotics/storageref/storageref.proto";
import "github.com/aperturerobotics/objectsig/objectsig.proto";

// Validator holds information about a validator.
message Validator {
  // PubKey is the validator's public key.
  bytes pub_key = 1;
  // VotingPower is the voting power of the validator.
  uint64 voting_power = 2;
  // OperationMode is the operation mode of the validator.
  OperationMode operation_mode = 3;

  // OperationMode is the operation mode of the validator.
  enum OperationMode {
    // OperationMode_STAGING indicates the validator is not currently online.
    // A validator can voluntarily step-down for some time this way.
    OperationMode_STAGING = 0;
    // OperationMode_OPERATING indicates the validator is currently operating.
    OperationMode_OPERATING = 1;
  }
}

// ValidatorSet is the current set of validators.
message ValidatorSet {
  // Validators are the address to validator object pairings.
  // Validators are sorted by crc32 of pubkey and voting power (varint) concatinated.
  repeated Validator validators = 1;
}

// Block is a committed block in the chain.
message Block {
  // BlockHeaderRef is the reference to the block header.
  // Must be signed by the proposer.
  storageref.StorageRef block_header_ref = 1;
  // VoteRefs are the validator votes included to justify this block.
  repeated storageref.StorageRef vote_refs = 2;
}

// BlockRoundInfo contains information about the round.
message BlockRoundInfo {
  uint64 height = 1;
  uint64 round = 2;
}

// BlockHeader is the header of a block.
message BlockHeader {
  // GenesisRef contains a reference to the Genesis object.
  storageref.StorageRef genesis_ref = 1;
  // ChainConfigRef contains a reference to the ChainConfig object.
  storageref.StorageRef chain_config_ref = 2;
  // NextChainConfigRef contains a reference to the next ChainConfig object.
  storageref.StorageRef next_chain_config_ref = 3;
  // LastBlockRef contains a reference to the last BlockHeader object.
  storageref.StorageRef last_block_ref = 4;
  // RoundInfo contains the round information.
  BlockRoundInfo round_info = 5;
  // BlockTs is the timestamp the block header was proposed.
  timestamp.Timestamp block_ts = 6;
  // ProposerId is the proposer identifier.
  string proposer_id = 7;
  // StateRef is the reference to the application state.
  storageref.StorageRef state_ref = 8;
}

// Vote is a signature on a proposal by a validator.
message Vote {
  // BlockHeaderRef is the reference to the block header.
  storageref.StorageRef block_header_ref = 1;
}

// Genesis is the initial object starting the blockchain.
message Genesis {
  // ChainId is used to differentiate between chains, but could be set to anything.
  // It is an opaque value and ignored by the system.
  string chain_id = 1;
  // Timestamp contains the time the genesis block was formed.
  timestamp.Timestamp timestamp = 2;
  // EncStrategy is the encryption strategy to use.
  EncryptionStrategy enc_strategy = 3;
  // InitChainConfig is the initial chain configuration.
  storageref.StorageRef init_chain_config_ref = 4;
}

enum EncryptionStrategy {
  EncryptionStrategy_Invalid = 0;
  EncryptionStrategy_ConvergentImmutable = 1;
  // EncryptionStrategy_ConvergentMutable = 2;
}

// ChainConfig is the configuration for the blockchain. Can be updated each block.
message ChainConfig {
  // TimingConfig contains the timing configuration.
  TimingConfig timing_config = 1;
  // ValidatorSetRef contains a reference to the computed validator set.
  // This must match the last block NextValidatorSetRef.
  storageref.StorageRef validator_set_ref = 2;
}

// TimingConfig is the timing configuration for the blockchain.
// Timings are in milliseconds (ms).
message TimingConfig {
  // MinProposeAfterBlock is the minimum time after a block before the first round starts.
  // The round starts at block[i-1].Timestamp + MinProposeAfterBlock
  uint32 min_propose_after_block = 1;
  // MaxProposeAfterBlock is the maximum time to wait for at least one tx before an empty block is made.
  // This is a soft limit, it's still OK to propose a empty block before this timeout.
  uint32 max_propose_after_block = 2;
  // RoundLength is the length of each round.
  uint32 round_length = 3;
}

// NodeMessage is a message submitted to the network by a peer.
message NodeMessage {
  // GenesisRef contains a reference to the Genesis object.
  storageref.StorageRef genesis_ref = 1;
  // PrevMsgRef is the reference to the previous NodeMessage.
  storageref.StorageRef prev_msg_ref = 2;
  // Timestamp is the timestamp of this NodeMessage.
  // The timestamp must be after the timestamp of the previous message.
  timestamp.Timestamp timestamp = 3;
  // InnerRef is the reference to the inner object sent in this message.
  storageref.StorageRef inner_ref = 4;
  // MessageType is the type of message this is.
  NodeMessageType message_type = 5;
}

// ChainPubsubMessage is a message emitted by a node in the chain pubsub channel.
message ChainPubsubMessage {
  // NodeMessageRef contains a reference to the node message being sent.
  storageref.StorageRef node_message_ref = 1;
  // PeerId is the peer ID encoded in base58
  string peer_id = 2;
}

// NodeMessageType identifies the purpose of the node message.
// Block commits are sent on their own channel, so that read-only clients can ignore voting chatter.
enum NodeMessageType {
  NodeMessageType_UNKNOWN = 0;
  NodeMessageType_VOTE = 1;
  NodeMessageType_BLOCK_COMMIT = 2;
}
